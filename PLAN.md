# План реализации программы ChatList

## Этап 1: Подготовка проекта и структуры

1.1. Создать структуру проекта:
- `main.py` - главный файл с GUI интерфейсом
- `db.py` - модуль для работы с SQLite
- `models.py` - модуль для работы с моделями нейросетей
- `network.py` - модуль для HTTP-запросов к API
- `.env` - файл для хранения API-ключей
- `requirements.txt` - зависимости проекта

1.2. Установить зависимости:
- PyQt5
- requests или httpx
- python-dotenv (для работы с .env)
- sqlite3 (встроен в Python)

## Этап 2: База данных

2.1. Создать модуль `db.py`:
- Функция инициализации БД (создание таблиц)
- Функции для работы с таблицей `prompts`:
  - Добавление промта
  - Получение списка промтов
  - Поиск промтов
  - Сортировка промтов
- Функции для работы с таблицей `models`:
  - Добавление модели
  - Получение активных моделей
  - Обновление статуса модели
  - Поиск и сортировка моделей
- Функции для работы с таблицей `results`:
  - Сохранение результатов
  - Получение сохраненных результатов
  - Поиск и сортировка результатов
- Функции для работы с таблицей `settings`:
  - Сохранение настроек
  - Загрузка настроек

2.2. Создать схему базы данных (см. DATABASE.md)

## Этап 3: Работа с API

3.1. Создать модуль `network.py`:
- Функция для отправки запроса к OpenAI API
- Функция для отправки запроса к DeepSeek API
- Функция для отправки запроса к Groq API
- Универсальная функция отправки запроса (определение типа API по модели)
- Обработка ошибок и таймаутов
- Логирование запросов

3.2. Создать модуль `models.py`:
- Класс или структура для представления модели нейросети
- Функция получения списка активных моделей из БД
- Функция отправки промта во все активные модели
- Обработка результатов запросов

## Этап 4: Графический интерфейс - Основная структура

4.1. Создать главное окно в `main.py`:
- Класс MainWindow наследуется от QMainWindow
- Разметка интерфейса (QVBoxLayout, QHBoxLayout)
- Область ввода промта (QTextEdit)
- Кнопка "Отправить запрос"
- Область для отображения результатов

4.2. Создать виджет для работы с промтами:
- Выпадающий список или список сохраненных промтов (QComboBox/QListWidget)
- Кнопка "Выбрать промт"
- Кнопка "Сохранить промт" (с полями для тегов)

## Этап 5: Графический интерфейс - Таблица результатов

5.1. Создать временную таблицу результатов в памяти:
- Структура данных для хранения результатов (список словарей)
- Поля: название модели, текст ответа, selected (bool)

5.2. Создать виджет таблицы (QTableWidget):
- Колонки: Checkbox, Название модели, Ответ
- Настройка отображения (ширина колонок, выравнивание)
- Обработка кликов по чекбоксам

5.3. Реализовать обновление таблицы:
- Очистка таблицы при новом запросе
- Заполнение таблицы после получения ответов от моделей
- Индикатор загрузки во время отправки запросов

## Этап 6: Сохранение результатов

6.1. Реализовать кнопку "Сохранить":
- Получение всех строк с selected = True
- Сохранение в таблицу `results` через `db.py`
- Очистка временной таблицы после сохранения
- Уведомление пользователя об успешном сохранении

6.2. Создать виджет для просмотра сохраненных результатов:
- Таблица с сохраненными результатами
- Фильтры и поиск
- Возможность удаления записей

## Этап 7: Управление моделями

7.1. Создать окно/диалог для управления моделями:
- Список всех моделей
- Добавление новой модели (поля: name, api-url, api-id, переменная для API-ключа)
- Редактирование модели
- Включение/отключение модели (is_active)
- Удаление модели

7.2. Интегрировать управление моделями в главное окно:
- Меню или кнопка "Настройки моделей"

## Этап 8: Управление промтами

8.1. Создать окно/диалог для управления промтами:
- Список всех сохраненных промтов
- Добавление нового промта с тегами
- Редактирование промта
- Удаление промта
- Поиск и фильтрация по тегам

8.2. Интегрировать управление промтами в главное окно:
- Выпадающий список с сохраненными промтами
- Быстрый выбор промта из списка

## Этап 9: Дополнительные функции

9.1. Реализовать поиск и сортировку:
- Поиск в таблице промтов
- Поиск в таблице моделей
- Поиск в таблице результатов
- Сортировка по дате, названию и т.д.

9.2. Реализовать экспорт результатов:
- Экспорт в Markdown
- Экспорт в JSON
- Кнопка "Экспорт" в интерфейсе результатов

9.3. Реализовать логирование:
- Лог файл для запросов к API
- Лог ошибок
- Настройка уровня логирования

## Этап 10: Тестирование и оптимизация

10.1. Тестирование основных функций:
- Тестирование работы с БД
- Тестирование отправки запросов к API
- Тестирование интерфейса

10.2. Обработка ошибок:
- Обработка ошибок сети
- Обработка ошибок API
- Обработка ошибок БД
- Понятные сообщения об ошибках для пользователя

10.3. Оптимизация:
- Оптимизация запросов к БД
- Оптимизация интерфейса (асинхронные запросы)
- Проверка производительности

## Этап 11: Финальная сборка

11.1. Создать .env.example файл с примерами переменных окружения

11.2. Обновить requirements.txt со всеми зависимостями

11.3. Создать README.md с инструкциями по установке и использованию

11.4. Создать исполняемый файл (PyInstaller)

## Этап 12: AI-ассистент для улучшения промтов

12.1. Создать модуль `prompt_improver.py`:
- Функция для отправки промта на улучшение в выбранную модель
- Функция для генерации улучшенной версии промта
- Функция для генерации 2-3 вариантов переформулировки
- Функция для адаптации промта под разные типы моделей:
  - Для кода (технические задачи, программирование)
  - Для анализа (аналитические задачи, исследования)
  - Для креативных задач (творчество, генерация контента)
- Обработка ответов от модели и парсинг результатов

12.2. Создать диалог `prompt_improver_dialog.py`:
- Класс `PromptImproverDialog` для отображения результатов улучшения
- Поля для отображения:
  - Исходный промт (read-only)
  - Улучшенный промт (редактируемый)
  - Альтернативные варианты (2-3 варианта переформулировки)
  - Адаптированные версии для разных типов моделей (опционально)
- Кнопки для каждого варианта: "Подставить в поле ввода"
- Кнопка "Сохранить улучшенный промт" (с тегами)
- Кнопка "Отменить"

12.3. Интегрировать в главное окно:
- Добавить кнопку "Улучшить промт" рядом с полем ввода промта
- При нажатии:
  - Проверка наличия текста в поле промта
  - Выбор модели для улучшения (выпадающий список активных моделей)
  - Отправка запроса на улучшение
  - Отображение диалога с результатами
- Обработка выбора варианта:
  - При нажатии "Подставить в поле ввода" - замена текста в поле промта
  - Обновление интерфейса

12.4. Создать промпты-шаблоны для улучшения:
- Шаблон для общего улучшения промта
- Шаблон для генерации альтернативных формулировок
- Шаблоны для адаптации под разные типы задач:
  - Технический/код: "Переформулируй промт для технической задачи..."
  - Аналитический: "Адаптируй промт для аналитической задачи..."
  - Креативный: "Переформулируй промт для творческой задачи..."

12.5. Реализовать логику улучшения:
- Формирование запроса к модели с промптом-шаблоном
- Парсинг ответа модели (может быть в формате JSON или текста)
- Извлечение:
  - Улучшенной версии промта
  - Альтернативных вариантов (список)
  - Адаптированных версий (если запрошено)
- Валидация и обработка ошибок

12.6. Улучшить пользовательский опыт:
- Индикатор загрузки во время обработки
- Возможность отменить операцию
- Сохранение истории улучшений (опционально)
- Копирование вариантов в буфер обмена
- Предпросмотр улучшенного промта перед подстановкой

12.7. Настройки AI-ассистента:
- Выбор модели по умолчанию для улучшения промтов
- Настройка количества альтернативных вариантов (2-5)
- Включение/выключение адаптации под типы моделей
- Сохранение настроек в таблицу `settings`

